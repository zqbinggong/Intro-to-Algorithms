//对区间的模糊排序
/*
1. Find-Intersection(A,B,p,s,m,n):寻找并返回（A,B)中p到s段的公共子集(m,n)
2. Partition-Right(A,B,p,s,m):根据m，对（A,B）排序，返回排序后m的下一位置
3. Partition-Left-Middle(A,B,p,r,n)
4. Fuzzy-Sort(A,B,p,s)
*/
public class Fuzzy {
	
	public static void main(String[] args){
		int[] a = new int[]{88,14,55,23,36,68,42,85};
		int[] b = new int[]{99,29,73,24,68,105,59,94};
		fuzzySort(a,b,0,a.length-1);
		for(int i = 0; i < a.length; i++)
			System.out.print(a[i]+"\t");
		System.out.println();
		for(int i = 0; i < b.length; i++)
			System.out.print(b[i]+"\t");
		System.out.println();
	}
	public static void fuzzySort(int[] a, int[] b, int p, int s){
		if(p < s){
			int[] index = new int[2];
			index = partitionSame(a,b,p,s);
			fuzzySort(a,b,p,index[0]-1);
			fuzzySort(a,b,index[1]+1,s);
		}
	}
	private static int[] partitionSame(int[] a, int[] b, int p, int r) {
		// TODO Auto-generated method stub
		int[] index = new int[2];
		
		int xa = a[p];
		int xb = b[p];
		int i = p;
		int h = p;
		for(int j = p+1; j <= r; j++){
			if(b[j] < xa){
				int ya = a[j];
				int yb = b[j];
				a[j] = a[h+1];
				b[j] = b[h+1];
				a[i++] = ya;
				b[i++] = yb;
				h++;
			}else if(a[j] <= xb && b[j] >= xa){
				swap(a,h+1,j);
				swap(b,h+1,j);
				h++;
			}
		}
		index[0] = i;
		index[1] = h;
		return index;
	}
	
	
	private static void swap(int[] arr, int i, int j) {
		// TODO Auto-generated method stub
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}

}

