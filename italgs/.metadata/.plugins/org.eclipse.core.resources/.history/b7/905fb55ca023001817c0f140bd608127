
public class LinearTimeSort {
	
	//计数排序,版本1,稳定但不是原址排序
	public static void countSort(int[] a, int b[], int k){
		int[] c = new int[k+1];
		for(int i = 0; i < a.length; i++)
			c[a[i]] += 1;
		for(int i = 1; i < k+1; i++)
			c[i] += c[i-1];
		for(int i = a.length-1; i >= 0; i--){
			b[c[a[i]]-1] = a[i];//注意这里有个减1的操作
			c[a[i]] -= 1;
		}
		
	}
	
	//计数排序,版本2,原址但不稳定
	public static void countSort2(int[] a, int k){
		int[] c = new int[k+1];
		for(int i = 0; i < a.length; i++)
			c[a[i]] += 1;
		int p = 0;
		for(int i = 0; i <= k; i++)
			for(int j = 0; j < c[i]; j++)
				a[p++] = i;
	}
	
	//水壶问题
	public static void matchJugs(int[] r, int[] b, int p, int s){
		if(p < s){
			/*错误版本，错误在于没有深入理解快速排序中，随机partition中，随机选取一个主元后，首先要将该主元换/
			 * 到数组的尾端
			int k = (int) Math.round(Math.random()*(s-p)+p);
			int q = partitionRed(r,p,s,r[k]);
			partitionBlue(b,p,s,r[q]);
			matchJugs(r, b, p, q-1);
			matchJugs(r, b, q+1, s);
			*/
			int k = (int) Math.round(Math.random()*(s-p)+p);
			int q = partitionRed(r,p,s,k);
			partitionBlue(b,p,s,r[q]);
			matchJugs(r, b, p, q-1);
			matchJugs(r, b, q+1, s);
		}
	}

	private static void partitionBlue(int[] b, int p, int s, int x) {
		// TODO Auto-generated method stub
		int j = p - 1;
		for(int i = p; i <= s; i++){
			if(b[i] <= x){
				swap(b,i,++j);
			}
		}
	}

	private static int partitionRed(int[] r, int p, int s, int k) {
		// TODO Auto-generated method stub
		int x = r[k];
		swap(r,k,s);
		int j = p - 1;
		for(int i = p; i <= s; i++){
			if(r[i] <= x){
				swap(r,i,++j);
			}
		}
		swap()
		return j;
	}

	private static void swap(int[] arr, int i, int j) {
		// TODO Auto-generated method stub
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	
	
	

}
